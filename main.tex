\documentclass{article}
\usepackage{graphicx} 
\usepackage{lipsum}   
\usepackage[margin=1in]{geometry} 
\usepackage{amssymb}
\usepackage{titling}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{tikz}

\begin{document}
\begin{titlepage}
    \begin{center}
        
        \Large\textbf{National Autonomous University of Mexico} \\
        \Large{School of Engineering} \\
        \Large{División de Ingeniería Eléctrica}
        
        \vspace*{5cm}
        
        \Huge\textbf{Code notes for ICPC 2024}\\[0.5cm]
        
        \Large\textit{Laboratorio de Señales y Sistemas}
        
        \vspace{4cm}
        
        \Large
        \textbf{Alumnos:} \\
        Salazar Rubi Héctor Manuel\\
        Valenzuela Ascencio Gustavo
        
        \vspace{2cm}
        
        \Large
        \textbf{Profesor:} \\
        Dr. Ing. Lauro Fernando Vázquez Alberto
        
        \vfill
        
        \Large{6 de octubre del 2024}

    \end{center}
\end{titlepage}
\lstset{ % Set options for the listings environment
  language=C++, % Choose the language of the code
  basicstyle=\ttfamily\small, % Set font style and size
  keywordstyle=\color{violet}, % Set color for keywords
  stringstyle=\color{red}, % Set color for strings
  commentstyle=\color{blue}, % Set color for comments
  breaklines=true, % Enable line breaking
  frame=single % Add a frame around the code
}
\section{Binary search in the answer}
\lstset{ % Set options for the listings environment
  language=Python, % Choose the language of the code
  basicstyle=\ttfamily\small, % Set font style and size
  keywordstyle=\color{violet}, % Set color for keywords
  stringstyle=\color{red}, % Set color for strings
  commentstyle=\color{blue}, % Set color for comments
  breaklines=true, % Enable line breaking
  frame=single % Add a frame around the code
}
\subsection{Binary searching the square root of a number}
\begin{lstlisting}
def binSearchInAns(x):
l = 1
r = 1000000000
while(l>=r):
    mid = (l + (r-l))//2
    if(mid*mid == x):
        return True
    if(mid*mid<x):
        l = mid+1
    else:
        r = mid-1
return False
\end{lstlisting}

\lstset{ % Set options for the listings environment
  language=C++, % Choose the language of the code
  basicstyle=\ttfamily\small, % Set font style and size
  keywordstyle=\color{violet}, % Set color for keywords
  stringstyle=\color{red}, % Set color for strings
  commentstyle=\color{blue}, % Set color for comments
  breaklines=true, % Enable line breaking
  frame=single % Add a frame around the code
}


\subsection{Binary searching kth number not divisible by n}
\begin{lstlisting}
ll bsAns(ll x, ll n){
    ll l = 1, r = 1e10, res = r;
    while (l <= r) {
        ll m = l + (r - l) / 2;
        if ((m - m/n) >= x) {
            if (m % n != 0)
                res = m;
            r = m - 1;  
        }
        else {
            l = m + 1;
        }
    }
    return res;
}
\end{lstlisting}

\section{Graph Theory}
\subsection{Topological sort}
\begin{lstlisting}
vector<int> ans;
 
void dfs(int v) {
    visited[v] = true;
    for (int u : adj[v]) {
        if (!visited[u])
            dfs(u);
    }
    ans.push_back(v);
}
 
void topological_sort() {
    visited.assign(n+1, false);
    ans.clear();
    for (int i = 1; i <= n; ++i) {
        if (!visited[i]) {
            dfs(i);
        }
    }
    reverse(ans.begin(), ans.end());
}
\end{lstlisting}


\begin{lstlisting}
int lis(vector<ll> const& a) {
    int n = a.size();
    const int INF = 1e9;
    vector<int> d(n+1, INF);
    d[0] = -INF;

    for (int i = 0; i < n; i++) {
        int l = upper_bound(d.begin(), d.end(), a[i]) - d.begin();
        if (d[l-1] < a[i] && a[i] < d[l])
            d[l] = a[i];
    }

    int ans = 0;
    for (int l = 0; l <= n; l++) {
        if (d[l] < INF)
            ans = l;
    }
    return ans;
}
\end{lstlisting}

LIS en $O(nlogn)$

\begin{lstlisting}
vector<vector<int>> adj(MAX); // adjacency list of graph
vector<bool> visited;
vector<int> parents;
vector<int> ans;
int depth = 0;
 
void bfs(int v) {
    visited.assign(n+1,false);
    parents.assign(n+1, 0);
    queue<int> q;
    depth++;
    visited[v] = true;
    parents[v] = 0;
    q.push(v);
    while(!q.empty()){
        v = q.front();
        q.pop();
        depth++;
        if(v == n){
            break;
        }
        for(auto a : adj[v]){
            if(!visited[a]){
                //cout<<a<<endl;
                parents[a] = v;
                visited[a] = true;
                q.push(a);
            }
        }
    }

    if(visited[n]){
        int esc = parents[n];
        ans.push_back(n);
        while(esc != 0){
            ans.push_back(esc);
            esc = parents[esc];
        }
    }
    reverse(ans.begin(), ans.end());
}
\end{lstlisting}

Restoring BFS shortest path

\begin{lstlisting}

void computeLPSArray(string& pat, int M, vector<int>& lps){
    // Length of the previous longest prefix suffix
    int len = 0;

    // lps[0] is always 0
    lps[0] = 0;

    // loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else // (pat[i] != pat[len])
        {
            if (len != 0) {
                len = lps[len - 1];
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
            }
        }
    }
}

// Prints occurrences of pat in txt
int KMPSearch(string& pat, string& txt)
{
    int M = pat.length();
    int N = txt.length();

    // Create lps[] that will hold the longest prefix suffix
    // values for pattern
    vector<int> lps(M);

    int result = 0;

    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

    int i = 0; // index for txt
    int j = 0; // index for pat
    while ((N - i) >= (M - j)) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }

        if (j == M) {
            result++;
            j = lps[j - 1];
        }

        // Mismatch after j matches
        else if (i < N && pat[j] != txt[i]) {

            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
            else
                i = i + 1;
        }
    }
    return result;
}
\end{lstlisting}
KMP Algorithm

\begin{lstlisting}

// Function to compute the prefix function (also called the "failure function") for KMP
vector<int> lpsFunction(const vector<int>& pattern) {
    int m = pattern.size();
    vector<int> lps(m, 0);  // Longest Prefix Suffix (LPS) array
    int length = 0;
    int i = 1;

    while (i < m) {
        if (pattern[i] == pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }

    return lps;
}

// Function to perform KMP search to count occurrences of the pattern in the text
int KMPSearch(const vector<int>& pattern, const vector<int>& text) {
    int n = text.size();
    int m = pattern.size();

    if (m == 0 || n == 0 || m > n) return 0;

    vector<int> lps = lpsFunction(pattern);
    int i = 0;  // index for text[]
    ll j = 0;  // index for pattern[]
    int cnt = 0;

    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }

        if (j == m) {
            cnt++;  // Found a match
            j = lps[j - 1];
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }

    return cnt;
}

\end{lstlisting}

Integer KMP

\begin{lstlisting}
int lis(vector<int> const& a) {
    int n = a.size();
    vector<int> d(n, 1);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i])
                d[i] = max(d[i], d[j] + 1);
        }
    }

    int ans = d[0];
    for (int i = 1; i < n; i++) {
        ans = max(ans, d[i]);
    }
    return ans;
}

vector<int> lis(vector<int> const& a) {
    int n = a.size();
    vector<int> d(n, 1), p(n, -1);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i] && d[i] < d[j] + 1) {
                d[i] = d[j] + 1;
                p[i] = j;
            }
        }
    }

    int ans = d[0], pos = 0;
    for (int i = 1; i < n; i++) {
        if (d[i] > ans) {
            ans = d[i];
            pos = i;
        }
    }

    vector<int> subseq;
    while (pos != -1) {
        subseq.push_back(a[pos]);
        pos = p[pos];
    }
    reverse(subseq.begin(), subseq.end());
    return subseq;
}
\end{lstlisting}
LIS + restoring
\begin{lstlisting}
const double EPS = 1E-9;
int n;
vector < vector<double> > a (n, vector<double> (n));

double det = 1;
for (int i=0; i<n; ++i) {
    int k = i;
    for (int j=i+1; j<n; ++j)
        if (abs (a[j][i]) > abs (a[k][i]))
            k = j;
    if (abs (a[k][i]) < EPS) {
        det = 0;
        break;
    }
    swap (a[i], a[k]);
    if (i != k)
        det = -det;
    det *= a[i][i];
    for (int j=i+1; j<n; ++j)
        a[i][j] /= a[i][i];
    for (int j=0; j<n; ++j)
        if (j != i && abs (a[j][i]) > EPS)
            for (int k=i+1; k<n; ++k)
                a[j][k] -= a[i][k] * a[j][i];
}

cout << det;
\end{lstlisting}
Determinant of a matrix

\begin{lstlisting}
const double EPS = 1E-9;

int compute_rank(vector<vector<double>> A) {
    int n = A.size();
    int m = A[0].size();

    int rank = 0;
    vector<bool> row_selected(n, false);
    for (int i = 0; i < m; ++i) {
        int j;
        for (j = 0; j < n; ++j) {
            if (!row_selected[j] && abs(A[j][i]) > EPS)
                break;
        }

        if (j != n) {
            ++rank;
            row_selected[j] = true;
            for (int p = i + 1; p < m; ++p)
                A[j][p] /= A[j][i];
            for (int k = 0; k < n; ++k) {
                if (k != j && abs(A[k][i]) > EPS) {
                    for (int p = i + 1; p < m; ++p)
                        A[k][p] -= A[j][p] * A[k][i];
                }
            }
        }
    }
    return rank;
}

\end{lstlisting}
Rank of a matrix (Linearly independent rows)

\begin{lstlisting}
const double EPS = 1e-9;
const int INF = 2; // it doesn't actually have to be infinity or a big number

int gauss (vector < vector<double> > a, vector<double> & ans) {
    int n = (int) a.size();
    int m = (int) a[0].size() - 1;

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col) {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < EPS)
            continue;
        for (int i=col; i<=m; ++i)
            swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j=col; j<=m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i) {
        double sum = 0;
        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return INF;
    return 1;
}
\end{lstlisting}

Gauss-Jordan

\begin{lstlisting}
const int INF = 1000000000;
vector<vector<pair<int, int>>> adj;

void dijkstra(int s, vector<int> & d, vector<int> & p) {
    int n = adj.size();
    d.assign(n, INF);
    p.assign(n, -1);

    d[s] = 0;
    using pii = pair<int, int>;
    priority_queue<pii, vector<pii>, greater<pii>> q;
    q.push({0, s});
    while (!q.empty()) {
        int v = q.top().second;
        int d_v = q.top().first;
        q.pop();
        if (d_v != d[v])
            continue;

        for (auto edge : adj[v]) {
            int to = edge.first;
            int len = edge.second;

            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                p[to] = v;
                q.push({d[to], to});
            }
        }
    }
}
\end{lstlisting}
Dijkstra

\begin{lstlisting}
void solve()
{
    vector<int> d(n, INF);
    d[v] = 0;
    vector<int> p(n, -1);

    for (;;) {
        bool any = false;
        for (Edge e : edges)
            if (d[e.a] < INF)
                if (d[e.b] > d[e.a] + e.cost) {
                    d[e.b] = d[e.a] + e.cost;
                    p[e.b] = e.a;
                    any = true;
                }
        if (!any)
            break;
    }

    if (d[t] == INF)
        cout << "No path from " << v << " to " << t << ".";
    else {
        vector<int> path;
        for (int cur = t; cur != -1; cur = p[cur])
            path.push_back(cur);
        reverse(path.begin(), path.end());

        cout << "Path from " << v << " to " << t << ": ";
        for (int u : path)
            cout << u << ' ';
    }
}
\end{lstlisting}

Bellman-Ford with path restoring

\begin{lstlisting}
const int INF = 1000000000;
vector<vector<pair<int, int>>> adj;

bool spfa(int s, vector<int>& d) {
    int n = adj.size();
    d.assign(n, INF);
    vector<int> cnt(n, 0);
    vector<bool> inqueue(n, false);
    queue<int> q;

    d[s] = 0;
    q.push(s);
    inqueue[s] = true;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        inqueue[v] = false;

        for (auto edge : adj[v]) {
            int to = edge.first;
            int len = edge.second;

            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                if (!inqueue[to]) {
                    q.push(to);
                    inqueue[to] = true;
                    cnt[to]++;
                    if (cnt[to] > n)
                        return false;  // negative cycle
                }
            }
        }
    }
    return true;
}

\end{lstlisting}

Negative cycles version

\begin{lstlisting}
for (int k = 0; k < n; ++k) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (d[i][k] < INF && d[k][j] < INF)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]); 
        }
    }
}
\end{lstlisting}
Floyd Warshall algorithm

\begin{lstlisting}
vector<int> parent, rank;

void make_set(int v) {
    parent[v] = v;
    rank[v] = 0;
}

int find_set(int v) {
    if (v == parent[v])
        return v;
    return parent[v] = find_set(parent[v]);
}

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            rank[a]++;
    }
}

struct Edge {
    int u, v, weight;
    bool operator<(Edge const& other) {
        return weight < other.weight;
    }
};

int n;
vector<Edge> edges;

int cost = 0;
vector<Edge> result;
parent.resize(n);
rank.resize(n);
for (int i = 0; i < n; i++)
    make_set(i);

sort(edges.begin(), edges.end());

for (Edge e : edges) {
    if (find_set(e.u) != find_set(e.v)) {
        cost += e.weight;
        result.push_back(e);
        union_sets(e.u, e.v);
    }
}
\end{lstlisting}
Kruskal with DSU
\begin{lstlisting}
int main() {
    int n;
    vector<vector<int>> g(n, vector<int>(n));
    // reading the graph in the adjacency matrix

    vector<int> deg(n);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j)
            deg[i] += g[i][j];
    }

    int first = 0;
    while (first < n && !deg[first])
        ++first;
    if (first == n) {
        cout << -1;
        return 0;
    }

    int v1 = -1, v2 = -1;
    bool bad = false;
    for (int i = 0; i < n; ++i) {
        if (deg[i] & 1) {
            if (v1 == -1)
                v1 = i;
            else if (v2 == -1)
                v2 = i;
            else
                bad = true;
        }
    }

    if (v1 != -1)
        ++g[v1][v2], ++g[v2][v1];

    stack<int> st;
    st.push(first);
    vector<int> res;
    while (!st.empty()) {
        int v = st.top();
        int i;
        for (i = 0; i < n; ++i)
            if (g[v][i])
                break;
        if (i == n) {
            res.push_back(v);
            st.pop();
        } else {
            --g[v][i];
            --g[i][v];
            st.push(i);
        }
    }

    if (v1 != -1) {
        for (size_t i = 0; i + 1 < res.size(); ++i) {
            if ((res[i] == v1 && res[i + 1] == v2) ||
                (res[i] == v2 && res[i + 1] == v1)) {
                vector<int> res2;
                for (size_t j = i + 1; j < res.size(); ++j)
                    res2.push_back(res[j]);
                for (size_t j = 1; j <= i; ++j)
                    res2.push_back(res[j]);
                res = res2;
                break;
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (g[i][j])
                bad = true;
        }
    }

    if (bad) {
        cout << -1;
    } else {
        for (int x : res)
            cout << x << " ";
    }
}
\end{lstlisting}
Euler Tour

\begin{lstlisting}
void make_set(int v) {
    parent[v] = v;
    rank[v] = 0;
}

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            rank[a]++;
    }
}
\end{lstlisting}
DSU

\begin{lstlisting}
void make_set(int v) {
    parent[v] = make_pair(v, 0);
    rank[v] = 0;
    bipartite[v] = true;
}

pair<int, int> find_set(int v) {
    if (v != parent[v].first) {
        int parity = parent[v].second;
        parent[v] = find_set(parent[v].first);
        parent[v].second ^= parity;
    }
    return parent[v];
}

void add_edge(int a, int b) {
    pair<int, int> pa = find_set(a);
    a = pa.first;
    int x = pa.second;

    pair<int, int> pb = find_set(b);
    b = pb.first;
    int y = pb.second;

    if (a == b) {
        if (x == y)
            bipartite[a] = false;
    } else {
        if (rank[a] < rank[b])
            swap (a, b);
        parent[b] = make_pair(a, x^y^1);
        bipartite[a] &= bipartite[b];
        if (rank[a] == rank[b])
            ++rank[a];
    }
}

bool is_bipartite(int v) {
    return bipartite[find_set(v).first];
}
\end{lstlisting}
DSU for check bipartitness online
\begin{lstlisting}
 
ll  t[4*MAX];
 
// Shout-out to CP algo for the SegTree implementation: https://cp-algorithms.com/data_structures/segment_tree.html#memory-efficient-implementation
 
void buildSegTree(vector<ll> &a, int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        buildSegTree(a, v*2, tl, tm);
        buildSegTree(a, v*2+1, tm+1, tr);
        t[v] = t[v*2] + t[v*2+1];
    }
}
 
 
ll sum(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return 0;
    if (l == tl && r == tr) {
        return t[v];
    }
    int tm = (tl + tr) / 2;
    return sum(v*2, tl, tm, l, min(r, tm))
           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);
}
 
void update(int v, int tl, int tr, int pos, ll new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = t[v*2] + t[v*2+1];
    }
}
 
void solve(){
	int n,q; cin>>n>>q;
	vector<ll> v(n);
	for(int i=0; i<n; i++){
		cin>>v[i];
	}
	buildSegTree(v,1,0,n-1);
	for(int i=0; i<q;i++){
		int ty; cin>>ty;
		if(ty == 1){
			int k;
			ll u; cin>>k>>u;
			update(1,0,n-1,k-1,u);
		}else{
			int l,r; cin>>l>>r;
			cout<<sum(1,0,n-1,l-1,r-1)<<endl;
		}
	}
}
\end{lstlisting}
Seg-Tree Sum Queries
\begin{lstlisting}
ll  t[4*MAX];
 
// Shout-out to CP algo for the SegTree implementation: https://cp-algorithms.com/data_structures/segment_tree.html#memory-efficient-implementation
 
void buildSegTree(vector<ll> &a, int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        buildSegTree(a, v*2, tl, tm);
        buildSegTree(a, v*2+1, tm+1, tr);
        t[v] = min(t[v*2], t[v*2+1]); // Change to minimum
    }
}
 
 
ll query(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return LLONG_MAX; // Return maximum possible value for empty range
    if (l == tl && r == tr) {
        return t[v];
    }
    int tm = (tl + tr) / 2;
    return min(query(v*2, tl, tm, l, min(r, tm)),
               query(v*2+1, tm+1, tr, max(l, tm+1), r));
}
 
void update(int v, int tl, int tr, int pos, ll new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = min(t[v*2], t[v*2+1]); // Change to minimum
    }
}
 
void solve(){
	int n,q; cin>>n>>q;
	vector<ll> v(n);
	for(int i=0; i<n; i++){
		cin>>v[i];
	}
	buildSegTree(v,1,0,n-1);
	for(int i=0; i<q;i++){
		int ty; cin>>ty;
		if(ty == 1){
			int k;
			ll u; cin>>k>>u;
			update(1,0,n-1,k-1,u);
		}else{
			int l,r; cin>>l>>r;
			cout<<query(1,0,n-1,l-1,r-1)<<endl;
		}
	}
}
\end{lstlisting}
Segtree - Range minimum queries
\begin{lstlisting}
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = 0;
    }
}

void update(int v, int tl, int tr, int l, int r, int add) {
    if (l > r)
        return;
    if (l == tl && r == tr) {
        t[v] += add;
    } else {
        int tm = (tl + tr) / 2;
        update(v*2, tl, tm, l, min(r, tm), add);
        update(v*2+1, tm+1, tr, max(l, tm+1), r, add);
    }
}

int get(int v, int tl, int tr, int pos) {
    if (tl == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return t[v] + get(v*2, tl, tm, pos);
    else
        return t[v] + get(v*2+1, tm+1, tr, pos);
}
\end{lstlisting}
Lazy Seg-Tree

\begin{lstlisting}
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = max(t[v*2], t[v*2 + 1]);
    }
}

void push(int v) {
    t[v*2] += lazy[v];
    lazy[v*2] += lazy[v];
    t[v*2+1] += lazy[v];
    lazy[v*2+1] += lazy[v];
    lazy[v] = 0;
}

void update(int v, int tl, int tr, int l, int r, int addend) {
    if (l > r) 
        return;
    if (l == tl && tr == r) {
        t[v] += addend;
        lazy[v] += addend;
    } else {
        push(v);
        int tm = (tl + tr) / 2;
        update(v*2, tl, tm, l, min(r, tm), addend);
        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);
        t[v] = max(t[v*2], t[v*2+1]);
    }
}

int query(int v, int tl, int tr, int l, int r) {
    if (l > r)
        return -INF;
    if (l == tl && tr == r)
        return t[v];
    push(v);
    int tm = (tl + tr) / 2;
    return max(query(v*2, tl, tm, l, min(r, tm)), 
               query(v*2+1, tm+1, tr, max(l, tm+1), r));
}
\end{lstlisting}

Adding segments on Lazy Segtree (Maximum).


\end{document}
